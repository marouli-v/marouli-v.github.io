<!DOCTYPE html>
<title>Testing Sensors</title>
 </head>
  <body>
   <pr>Testing Sensors</pr>
   <script>
    (function(exports) {
  var slice = [].slice;
  // Get an "[object [[Class]]]" string with toString.call(value).
  var toString = {}.toString;

  // I can't think of a better way to ensure a value is a specific type other
  // than to create instances and use the `instanceof` operator.
  function HookerOverride(v) { this.value = v; }
  function HookerPreempt(v) { this.value = v; }
  function HookerFilter(c, a) { this.context = c; this.args = a; }

  // When a pre- or post-hook returns the result of this function, the value
  // passed will be used in place of the original function's return value. Any
  // post-hook override value will take precedence over a pre-hook override
  // value.
  exports.override = function(value) {
    return new HookerOverride(value);
  };

  // When a pre-hook returns the result of this function, the value passed will
  // be used in place of the original function's return value, and the original
  // function will NOT be executed.
  exports.preempt = function(value) {
    return new HookerPreempt(value);
  };

  // When a pre-hook returns the result of this function, the context and
  // arguments passed will be applied into the original function.
  exports.filter = function(context, args) {
    return new HookerFilter(context, args);
  };

  // Execute callback(s) for properties of the specified object.
  function forMethods(obj, props, callback) {
    var prop;
    if (typeof props === "string") {
      // A single prop string was passed. Create an array.
      props = [props];
    } else if (props == null) {
      // No props were passed, so iterate over all properties, building an
      // array. Unfortunately, Object.keys(obj) doesn't work everywhere yet, so
      // this has to be done manually.
      props = [];
      for (prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          props.push(prop);
        }
      }
    }
    // Execute callback for every method in the props array.
    var i = props.length;
    while (i--) {
      // If the property isn't a function...
      if (toString.call(obj[props[i]]) !== "[object Function]" ||
        // ...or the callback returns false...
        callback(obj, props[i]) === false) {
        // ...remove it from the props array to be returned.
        props.splice(i, 1);
      }
    }
    // Return an array of method names for which the callback didn't fail.
    return props;
  }

  // Monkey-patch (hook) a method of an object.
  exports.hook = function(obj, props, options) {
    //  console.log("exports.hook| Class: "+ arguments[0] +" FunctionName :"+ arguments[1])
    // If the props argument was omitted, shuffle the arguments.
    if (options == null) {
      options = props;
      props = null;
    }
    // If just a function is passed instead of an options hash, use that as a
    // pre-hook function.
    if (typeof options === "function") {
      options = {pre: options};
    }

    // Hook the specified method of the object.
    return forMethods(obj, props, function(obj, prop) {
       //console.log("==> Class: "+ obj +" FunctionName :"+ arguments[1])
        // The original (current) method.
      var orig = obj[prop];
       
      // The new hooked function.
      function hooked() {
          
        var result, origResult, tmp;

        // Get an array of arguments.
        var args = slice.call(arguments);
        
        
        // If passName option is specified, prepend prop to the args array,
        // passing it as the first argument to any specified hook functions.
        if (options.passName) {
          args.unshift(prop);
        }

        // If a pre-hook function was specified, invoke it in the current
        // context with the passed-in arguments, and store its result.
        if (options.pre) {
          result = options.pre.apply(this, args);
        }

        if (result instanceof HookerFilter) {
          // If the pre-hook returned hooker.filter(context, args), invoke the
          // original function with that context and arguments, and store its
          // result.
          origResult = result = orig.apply(result.context, result.args);
        } else if (result instanceof HookerPreempt) {
          // If the pre-hook returned hooker.preempt(value) just use the passed
          // value and don't execute the original function.
          origResult = result = result.value;
        } else {
            //console.log();
          // Invoke the original function in the current context with the
          // passed-in arguments, and store its result.
          origResult = orig.apply(this, arguments);
	  try{
	  //console.log("Hook==> Class: "+ obj +" FunctionName :"+ JSON.stringify(orig.name) + "\n");
	  }
	  catch(e){
	  console.log("HOOKINGSCRIPTERROR: " + e);
	  }
          // If the pre-hook returned hooker.override(value), use the passed
          // value, otherwise use the original function's result.
          result = result instanceof HookerOverride ? result.value : origResult;
        }

        if (options.post) {
          // If a post-hook function was specified, invoke it in the current
          // context, passing in the result of the original function as the
          // first argument, followed by any passed-in arguments.
          tmp = options.post.apply(this, [origResult].concat(args));
          if (tmp instanceof HookerOverride) {
            // If the post-hook returned hooker.override(value), use the passed
            // value, otherwise use the previously computed result.
            result = tmp.value;
          }
        }

        // Unhook if the "once" option was specified.
        if (options.once) {
          exports.unhook(obj, prop);
        }

        // Return the result!
        return result;
      }
      // Re-define the method.
      obj[prop] = hooked;
      // Fail if the function couldn't be hooked.
      if (obj[prop] !== hooked) { return false; }
      // Store a reference to the original method as a property on the new one.
      obj[prop]._orig = orig;
    });
  };

  // Get a reference to the original method from a hooked function.
  exports.orig = function(obj, prop) {
//       console.log("oncall| Class: "+ arguments[0] +" FunctionName :"+ arguments[1])
    return obj[prop]._orig;
  };

  // Un-monkey-patch (unhook) a method of an object.
  exports.unhook = function(obj, props) {
//       console.log("oncall| Class: "+ arguments[0] +" FunctionName :"+ arguments[1])
    return forMethods(obj, props, function(obj, prop) {
      // Get a reference to the original method, if it exists.
      var orig = exports.orig(obj, prop);
      // If there's no original method, it can't be unhooked, so fail.
      if (!orig) { return false; }
      // Unhook the method.
      obj[prop] = orig;
    });
  };
}(typeof exports === "object" && exports || this));


function getScript() {
            var e = new Error();
            console.log(e.stack);
            var trace = e.stack.split("\n");
	    console.log("trace done");
            url = trace[3].split("@");
	    console.log(url);
            ret = url[0].split(":");
	    console.log("ret done");
            ret2 = ret.slice(0, ret.length-2);
	    console.log("ret2 done");
            ret3 = ret2.join(":");
            return(ret3);
}

var patch = (function () {
    /*jshint evil: true */

    "use strict";

    var global = new Function("return this;")(), // Get a reference to the global object
        fnProps = Object.getOwnPropertyNames(Function); // Get the own ("static") properties of the Function constructor

    return function (original, originalRef, patches) {

        var ref = global[originalRef] = original, // Maintain a reference to the original constructor as a new property on the global object
            args = [],
            newRef, // This will be the new patched constructor
            i;

        patches.called = patches.called || originalRef; // If we are not patching static calls just pass them through to the original function

        for (i = 0; i < original.length; i++) { // Match the arity of the original constructor
            args[i] = "a" + i; // Give the arguments a name (native constructors don't care, but user-defined ones will break otherwise)
        }

        if (patches.constructed) { // This string is evaluated to create the patched constructor body in the case that we are patching newed calls
            args.push("'use strict'; return (!!this ? " + patches.constructed + " : " + patches.called + ").apply(null, arguments);"); 
        } else { // This string is evaluated to create the patched constructor body in the case that we are only patching static calls
            args.push("'use strict'; return (!!this ? new (Function.prototype.bind.apply(" + originalRef + ", [{}].concat([].slice.call(arguments))))() : " + patches.called + ".apply(null, arguments));");
        }

        newRef = new (Function.prototype.bind.apply(Function, [{}].concat(args)))(); // Create a new function to wrap the patched constructor
        newRef.prototype = original.prototype; // Keep a reference to the original prototype to ensure instances of the patch appear as instances of the original
        newRef.prototype.constructor = newRef; // Ensure the constructor of patched instances is the patched constructor



        return newRef; // Return the patched constructor
    };

}());



window.addEventListener("load", function(event) {
    console.log("FULLYLOADED_new");
	function addXMLRequestCallback(callback){
    var oldSend, i;
    if( XMLHttpRequest.callbacks ) {
        // we've already overridden send() so just add the callback
        XMLHttpRequest.callbacks.push( callback );
    } else {
        // create a callback queue
        XMLHttpRequest.callbacks = [callback];
        // store the native send()
        oldSend = XMLHttpRequest.prototype.send;
        // override the native send()
        XMLHttpRequest.prototype.send = function(){
            // process the callback queue
            // the xhr instance is passed into each callback but seems pretty useless
            // you can't tell what its destination is or call abort() without an error
            // so only really good for logging that a request has happened
            // I could be wrong, I hope so...
            // EDIT: I suppose you could override the onreadystatechange handler though
            for( i = 0; i < XMLHttpRequest.callbacks.length; i++ ) {
                XMLHttpRequest.callbacks[i]( this );
            }
            // call the native send()
            oldSend.apply(this, arguments);
        }
    }
}

(function() {
    var origOpen = XMLHttpRequest.prototype.open;
    XMLHttpRequest.prototype.open = function() {
        console.log('request started!');
        this.addEventListener('load', function() {
            console.log('request completed!');
            console.log(this.readyState); //will always be 4 (ajax is completed successfully)
            console.log("XMLDATARESPONSE;"+this.responseText+ ";"); //whatever the response was
        });
        origOpen.apply(this, arguments);
    };
})();


// e.g.
addXMLRequestCallback( function( xhr ) {
     console.log("FWEBAPILOGP;XMLSEND;"+"\n");
    console.log("FWEBAPILOGP;XMLSEND;"+ String(xhr.responseText)+ ";" ); // (an empty string)
});
addXMLRequestCallback( function( xhr ) {
	console.log("FWEBAPILOGP;XMLSEND;"+"\n");	    
	console.dir("FWEBAPILOGP;XMLSEND;"+ String(xhr)+ ";" ); // have a look if there is anything useful here
});
  });

// ==========================================   MOBILE SPECIFIC CALLS  ============================================= //

hook(XMLHttpRequest,"open",function() { 
	//alert("getCurrentPosition called"); 
	console.log("MWEBAPILOGP;XMLSEND;"+"\n");
});


Accelerometer = patch(Accelerometer, "AccelerometerOriginal", {
    constructed: function (arg) {
	console.log("MWEBAPILOG_new;Accelerometer;"+getScript()+";");
        return new AccelerometerOriginal(arg);
    }
});

Gyroscope = patch(Gyroscope, "GyroscopeOriginal", {
    constructed: function (arg) {
	console.log("MWEBAPILOG_new;Gyroscope;"+getScript()+";");
        return new GyroscopeOriginal(arg);
    }
});


hook(navigator.geolocation,"getCurrentPosition",function() { 
	//alert("getCurrentPosition called"); 
	console.log("MWEBAPILOGP;getCurrentPosition;"+ window.location.host + ";" + getScript() +";" + navigator.userAgent + "\n");
});

hook(navigator.geolocation,"watchPosition",function() { 
	//alert("watchPosition called"); 
	console.log("MWEBAPILOGP;watchPosition;"+ window.location.host + ";" + getScript() + ";" + navigator.userAgent + "\n");
});

hook(navigator,"getBattery",function() { // not supported by firefox
	//alert("getBattery called"); 
	console.log("MWEBAPILOG;getBattery;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});

hook(navigator.mediaDevices,"getUserMedia",function() { 
	console.log("MWEBAPILOGP;getUserMedia;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});

hook(navigator,"getUserMedia",function() { 
	console.log("MWEBAPILOGP;getUserMediaDep;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});

hook(navigator,"vibrate", function() {
	console.log("MWEBAPILOGP;vibrate;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});

hook(window,"addEventListener",function() {
	//console.log("EDWWWW MALAKA");
	console.log("MWEBAPILOG_new "+arguments[0]);
	console.log("MWEBAPILOG_new "+arguments[1].arguments[0]);
	var array = ['deviceproximity','userproximity','devicelight', 'deviceorientation', 'deviceorientationabsolute', 'devicemotion','orientationchange'];
	if (array.indexOf(arguments[0]) >= 0 ){
		console.log("MWEBAPILOG_new;"+ arguments[0] +";"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
	}
});

hook(screen.orientation,"addEventListener",function() {
	//console.log("EDWWWW MALAKA");
	console.log("MWEBAPILOG_new "+arguments[0]);
	var array = ['change'];
	if (array.indexOf(arguments[0]) >= 0 ){
		console.log("MWEBAPILOG_new;"+ arguments[0] +";"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
	}
});


hook(screen.orientation,"lock", function() {
	console.log("MWEBAPILOG;orientation.lock;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});


hook(screen,"mozLockOrientation", function() {
	console.log("MWEBAPILOG;mozLockOrientation;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});

hook(navigator,"lockOrientation", function() {
	console.log("MWEBAPILOG;lockOrientation;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});

/*
//hook(navigator.nfc,"requestAdapter", function() {
//	console.log("MWEBAPILOG;nfc.requestAdapter;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
//});

hook(navigator.ContactsManager,"clear", function() {
	console.log("MWEBAPILOG;ContactsManager.clear;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});

hook(navigator.ContactsManager,"find", function() {
	console.log("MWEBAPILOG;ContactsManager.find;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});

hook(navigator.ContactsManager,"remove", function() {
	console.log("MWEBAPILOG;ContactsManager.remove;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});

hook(navigator.ContactsManager,"save", function() {
	console.log("MWEBAPILOG;ContactsManager.save;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});
*/

// ======================================= 	NON MOBILE SPECIFIC CALLS      ======================================== //





//	-----	CANVAS	-----	//

hook(document, "createElement", function(){
	var array = ['canvas', 'webgl'];
	if (array.indexOf(arguments[0].toLowerCase()) >= 0) {
	console.log("FWEBAPILOG;" + arguments[0].toLowerCase() + ";"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
	}
});


hook(HTMLCanvasElement.prototype, "getContext", function(){
	var array = ['2d', 'webgl'];
	if (array.indexOf(arguments[0].toLowerCase()) >= 0) {
	console.log("FWEBAPILOG;HTMLCanvasElement.getContext("+arguments[0].toLowerCase()+");"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
	}
});


hook(CanvasRenderingContext2D.prototype, "fillRect", function(){
	console.log("FWEBAPILOG;CanvasRenderingContext2D.fillRect;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});

hook(CanvasRenderingContext2D.prototype, "fillText", function(){
	console.log("FWEBAPILOG;CanvasRenderingContext2D.fillText;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});

hook(HTMLCanvasElement.prototype, "toDataURL", function(){
	console.log("FWEBAPILOG;HTMLCanvasElement.toDataURL;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});

//	-----	WEBGL   -----	 //

const arr = Object.getOwnPropertyNames(WebGLRenderingContext.prototype).filter( x => {
	const t = Object.getOwnPropertyDescriptor(WebGLRenderingContext.prototype, x);
 	return !t.get && typeof WebGLRenderingContext.prototype[x] === 'function'
})

arr.forEach(function(i){
hook(WebGLRenderingContext.prototype, i, function(){
	console.log("FWEBAPILOG;WebGLRenderingContext."+i+";"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});
})

//	-----	TIMEZONE  -----	 //

hook(Date.prototype, "getTimezoneOffset", function(){
	console.log("FWEBAPILOG;getTimezoneOffset;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});

//	-----	LOCALSTORAGE  -----	 //

hook(Storage.prototype, "setItem", function(){
	console.log("FWEBAPILOG;Storage.setItem;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});


hook(Storage.prototype, "getItem", function(){
	console.log("FWEBAPILOG;Storage.getItem;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});

hook(Storage.prototype, "key", function(){
	console.log("FWEBAPILOG;Storage.key;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});

hook(Storage.prototype, "removeItem", function(){
	console.log("FWEBAPILOG;Storage.removeItem;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});

hook(Storage.prototype, "clear", function(){
	console.log("FWEBAPILOG;Storage.clear;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});


hook(navigator, "share", function(){
	console.log("FWEBAPILOG;navigator.share;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});

// --- PERMISSIONS
/*
hook(navigator.permissions, "query", function(){
	console.log("FWEBAPILOG;permissions.query;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});

hook(navigator.permissions, "revoke", function(){
	console.log("FWEBAPILOG;permissions.revoke;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});
*/
// --- AUDIO

hook(window.AudioContext.prototype, "close", function(){
	console.log("FWEBAPILOG;AudioContext.close;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});


hook(window.AudioContext.prototype, "createMediaElementSource", function(){
	console.log("FWEBAPILOG;AudioContext.createMediaElementSource;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});


hook(window.AudioContext.prototype, "createMediaStreamSource", function(){
	console.log("FWEBAPILOG;AudioContext.createMediaStreamSource;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});

hook(window.AudioContext.prototype, "createMediaStreamDestination", function(){
	console.log("FWEBAPILOG;AudioContext.createMediaStreamDestination;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});

hook(window.AudioContext.prototype, "createMediaStreamTrackSource", function(){
	console.log("FWEBAPILOG;AudioContext.createMediaStreamTrackSource;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});

hook(window.AudioContext.prototype, "getOutputTimestamp", function(){
	console.log("FWEBAPILOG;AudioContext.getOutputTimestamp;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});

hook(window.AudioContext.prototype, "resume", function(){
	console.log("FWEBAPILOG;AudioContext.resume;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});

hook(window.AudioContext.prototype, "suspend", function(){
	console.log("FWEBAPILOG;AudioContext.suspend;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});


hook(window.OfflineAudioContext.prototype, "suspend", function(){
	console.log("FWEBAPILOG;OfflineAudioContext.suspend;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});

hook(window.OfflineAudioContext.prototype, "resume", function(){
	console.log("FWEBAPILOG;OfflineAudioContext.resume;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});

hook(window.OfflineAudioContext.prototype, "startRendering", function(){
	console.log("FWEBAPILOG;OfflineAudioContext.startRendering;"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});

const arr2 = Object.getOwnPropertyNames(window.BaseAudioContext.prototype).filter( x => {
	const t = Object.getOwnPropertyDescriptor(window.BaseAudioContext.prototype, x);
 	return !t.get && typeof window.BaseAudioContext.prototype[x] === 'function'
})

arr2.forEach(function(k){
hook(window.BaseAudioContext.prototype, k, function(){
	console.log("FWEBAPILOG;BaseAudioContext."+k+";"+ window.location.host + ";" + getScript() + ";" +navigator.userAgent + "\n");
});
})

//xxxxxxxxxx BLOCK CONTEXT MENUS + LOGGING xxxxxxxxxxxxxxxx//
document.oncontextmenu = function() {
    return false;
}

/*
LinearAccelerationSensor = patch(LinearAccelerationSensor, "LinearAccelerationSensorOriginal", {
    constructed: function (arg) {
	console.log("MWEBAPILOG_new;LinearAccelerationSensor;"+"\n");
        return new LinearAccelerationSensorOriginal(arg);
    }
});

AbsoluteOrientationSensor = patch(AbsoluteOrientationSensor, "AbsoluteOrientationSensorOriginal", {
    constructed: function (arg) {
	console.log("MWEBAPILOG_new;AbsoluteOrientationSensor;"+"\n");
        return new AbsoluteOrientationSensorOriginal(arg);
    }
});

RelativeOrientationSensor = patch(RelativeOrientationSensor, "RelativeOrientationSensorOriginal", {
    constructed: function (arg) {
	console.log("MWEBAPILOG_new;RelativeOrientationSensor;"+"\n");
        return new RelativeOrientationSensorOriginal(arg);
    }
});
*/



console.log("--- Script 1 Injected in " + window.location + " ---");

/*
if (document.addEventListener) {
            document.addEventListener('contextmenu', function (e) {
                e.preventDefault();
            }, false);
        } else {
            document.attachEvent('oncontextmenu', function () {
                window.event.returnValue = false;
            });
        }
*/

/*
document.addEventListener("contextmenu", function (e) {
        console.log("Context menu blocked\n");
	e.preventDefault();
}, false);
*/

/*
function preventLongPressMenu(node) {
      node.ontouchstart = absorbEvent_;
      node.ontouchmove = absorbEvent_;
      node.ontouchend = absorbEvent_;
      node.ontouchcancel = absorbEvent_;
    }

function init() {
      preventLongPressMenu(document);
}

*/



</script>
   <script>
     window.addEventListener("devicemotion", function(event) {
      
      var touch = 0;
      //var ts = Math.round((new Date()).getTime() / 1000)
      var ts = (new Date()).getTime() / 1000
      //bth
      ////console.log(touch, ",", touch, "," ,"ACCEL,", ts, "," , event.accelerationIncludingGravity.x, "," , event.accelerationIncludingGravity.y , "," , event.accelerationIncludingGravity.z);
      ////console.log(touch, ",", touch, "," ,"GYRO,",  ts, "," , event.rotationRate.alpha , "," , event.rotationRate.beta , "," , event.rotationRate.gamma); 
      //accel
      ////console.log('devicemotion.event.acceleration', event.acceleration.x , event.acceleration.y , event.acceleration.z);
      ////console.log('devicemotion.event.accelerationIncludingGravity', event.accelerationIncludingGravity.x , event.accelerationIncludingGravity.y, event.accelerationIncludingGravity.z);
      //gyro
      ////console.log('devicemotion.event.rotationRate', event.rotationRate.alpha ,event.rotationRate.beta ,event.rotationRate.gamma); 
      //console.log('devicemotion.event.interval', event.interval); 
      
}, true);

    </script>
  </body>
</html>
